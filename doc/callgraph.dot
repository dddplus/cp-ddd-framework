digraph G {
   labelloc = "t";
   rankdir=LR;
   splines = polyline;
   node [shape=record];
   edge [style = dashed, fontsize=10];

   Carton [label="<Carton> Carton|<deductConsumableInventory> deductConsumableInventory|<cartonizationRule> cartonizationRule|<installConsumables> installConsumables|<transferFrom> transferFrom|<fulfill> fulfill|<bindOrder> bindOrder"];
   CartonBag [label="<CartonBag> CartonBag|<deductConsumableInventory> deductConsumableInventory|<fulfill> fulfill|<putOnPallet> putOnPallet"];
   ContainerBag [label="<ContainerBag> ContainerBag|<orderNoSet> orderNoSet|<confirmQty> confirmQty|<totalQty> totalQty|<totalPendingQty> totalPendingQty|<totalSku> totalSku"];
   ContainerItemBag [label="<ContainerItemBag> ContainerItemBag|<totalSku> totalSku"];
   Order [label="<Order> Order|<recommendPackQty> recommendPackQty|<checkedBy> checkedBy|<totalExpectedQty> totalExpectedQty|<recommendedPlatform> recommendedPlatform"];
   OrderBag [label="<OrderBag> OrderBag|<canceledBag> canceledBag|<consumableCostFirst> consumableCostFirst"];
   OrderCartons [label="<OrderCartons> OrderCartons|<totalCartonizedQty> totalCartonizedQty"];
   OrderLineBag [label="<OrderLineBag> OrderLineBag|<totalExpectedQty> totalExpectedQty"];
   Task [label="<Task> Task|<isEmpty> isEmpty|<removeOrderLines> removeOrderLines|<plan> plan"];
   TaskBag [label="<TaskBag> TaskBag|<totalCheckedQty> totalCheckedQty|<totalPendingQty> totalPendingQty|<platforms> platforms"];
   TaskCartons [label="<TaskCartons> TaskCartons|<contains> contains"];
   TaskOfOrderPending [label="<TaskOfOrderPending> TaskOfOrderPending|<confirmQty> confirmQty"];
   TaskOfSkuPending [label="<TaskOfSkuPending> TaskOfSkuPending|<confirmQty> confirmQty"];

   CartonBag -> Carton:deductConsumableInventory
   CartonBag -> Carton:fulfill
   CheckingAppService -> TaskOfOrderPending:confirmQty
   CheckingAppService -> CartonBag:fulfill
   CheckingAppService -> CartonBag:putOnPallet
   CheckingAppService -> Order:checkedBy
   CheckingAppService -> CartonBag:deductConsumableInventory
   CheckingAppService -> Carton:cartonizationRule
   CheckingAppService -> Carton:bindOrder
   CheckingAppService -> Carton:transferFrom
   CheckingAppService -> OrderBag:canceledBag
   CheckingAppService -> Order:recommendPackQty
   CheckingAppService -> Carton:installConsumables
   CheckingAppService -> Carton:fulfill
   CheckingAppService -> Order:recommendedPlatform
   CheckingAppService -> TaskBag:platforms
   CheckingAppService -> TaskBag:totalCheckedQty
   CheckingAppService -> TaskBag:totalPendingQty
   CheckingAppService -> Task:removeOrderLines
   CheckingAppService -> Task:isEmpty
   CheckingAppService -> Task:plan
   ConsumableExtPolicy -> OrderBag:consumableCostFirst
   ContainerBag -> ContainerItemBag:totalSku
   OrderNotCartonizedYet -> OrderCartons:totalCartonizedQty
   OrderNotFullyCartonized -> Order:totalExpectedQty
   OrderNotFullyCartonized -> OrderCartons:totalCartonizedQty
   Order -> OrderCartons:totalCartonizedQty
   Order -> OrderLineBag:totalExpectedQty
   TaskOfSkuPending -> ContainerBag:confirmQty
   Task -> TaskOfSkuPending:confirmQty
   Task -> ContainerBag:orderNoSet
   Task -> ContainerBag:totalPendingQty
   Task -> ContainerBag:totalQty
   Task -> ContainerBag:totalSku
   UniqueCodeConstraint -> TaskCartons:contains
}